// TODO: Figure out a a good way to send expressions over grpc.

syntax = "proto3";

package glaredb.arrowstore;

service ArrowStoreService {
    // Begin a transaction.
    rpc BeginTransaction(BeginTransactionRequest) returns (BeginTransactionResponse) {}

    // End a transaction.
    rpc EndTransaction(EndTransactionRequest) returns (EndTransactionResponse) {}

    // Allocate a table with the given schema.
    rpc AllocateTable(AllocateTableRequest) returns (AllocateTableResponse) {}

    // Insert a batch.
    rpc InsertBatch(InsertBatchRequest) returns (InsertBatchResponse) {}

    // Create an index.
    rpc CreateIndex(CreateIndexRequest) returns (CreateIndexResponse) {}

    // Prepare for a scan.
    rpc PrepareScan(PrepareScanRequest) returns (PrepareScanResponse) {}

    // Scan.
    rpc Scan(ScanRequest) returns (stream ArrowBatch) {}
}

// Transaction ontext provided in all request messages. Note that the store is
// not responsible for generating timestamps.
message TransactionContext {
    // A timestamp provided by the client.
    bytes timestamp = 1;
}

message BeginTransactionRequest {
    bytes timestamp = 1;
}

message BeginTransactionResponse {
    TransactionContext tx_ctx = 1;
}

enum TransactionEndType {
    ABORT = 0;
    COMMIT = 1;
}

message EndTransactionRequest {
    TransactionContext tx_ctx = 1;
    TransactionEndType end = 2;
}

message EndTransactionResponse {}

message AllocateTableRequest {
    TransactionContext tx_ctx = 1;
    string table = 2;
    // An arrow schema marshalled as json.
    // https://docs.rs/arrow/latest/arrow/datatypes/struct.Schema.html#method.to_json
    bytes schema = 3;
}

message AllocateTableResponse {}

message InsertBatchRequest {
    TransactionContext tx_ctx = 1;
    string table = 2;
    ArrowBatch batch = 3;
}

message InsertBatchResponse {}

message CreateIndexRequest {}

message CreateIndexResponse {}

// Identifier for the underlying cursor that's been opened on the storage side
// for scanning.
message CursorId {
    bytes id = 1;
}

// The arrow store may be sitting behind a consensus service, so we need to
// ensure that the client knows how to get to the store to begin scanning.
message NodeId {
    bytes id = 1;
}

enum ScanType {
    SCAN_TYPE_BASE = 0; // Base table scan.
}

// Prepare a cursor on the storage system for scanning.
message PrepareScanRequest {
    TransactionContext tx_ctx = 1;
    // The type of scan that we're performing.
    ScanType scan_type = 2;
    // Table to scan.
    string table = 3;
    // Projection to apply.
    //
    // An empty list will apply no projection.
    repeated uint64 projection = 4;
}

// Response for a scan preparation.
message PrepareScanResponse {
    NodeId node_id = 1;
    CursorId cursor_id = 2;
}

// Start scanning with the given cursor. Cursors should not be reused.
message ScanRequest {
    CursorId cursor_id = 1;
}

// Arrow record batches part of a stream.
message ArrowBatch {
    // The record batch encoded as an ipc message.
    bytes ipc_raw = 1;
}
