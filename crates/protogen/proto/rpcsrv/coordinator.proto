// Service definition for coordinator for distributed execution.

// TODO: Combine/split with service.proto as necessary.

syntax = "proto3";

package rpcsrv.coordinator;

import "metastore/catalog.proto";

// Lightweight session configuration.
message SessionContextConfig {
  // Database this session is for.
  bytes db_id = 1; // UUID

  // GCS bucket that contains this database.
  optional string gcs_bucket = 2;
}

message RegisterWorkerRequest {
  bytes node_id = 1; // UUID
}

message RegisterWorkerResponse {}

message DeregisterWorkerRequest {
  bytes node_id = 1; // UUID
}

message DeregisterWorkerResponse {}

message HeartbeatRequest {
  bytes node_id = 1; // UUID
}

message HeartbeatResponse {}

message PollWorkRequest {
  bytes node_id = 1; // UUID
}

message InternalTableReference {
  // OID of the table in the catalog.
  uint32 table_oid = 1;
}

// TODO: Deduplicate with service.proto
message ExternalTableReference {
  string database = 1;
  string schema = 2;
  string name = 3;
}

// TODO: Deduplicate with service.proto
message ResolvedTableReference {
  oneof reference {
    // Table exists in our catalog.
    InternalTableReference internal = 1;
    // Table exists in an external system that we need to contact.
    ExternalTableReference external = 2;
  }
}

// Dispatch the table access on remote server.
// TODO: Deduplicate with service.proto
message DispatchAccess {
  ResolvedTableReference table_ref = 1;
  repeated bytes args = 2;
  // gRPC doesn't really provide a way for Option<Vec<T>> or Option<Map<K,V>>
  // so we use a map and just check if it's empty or not in rust.
  map<string, bytes> options = 3;
}

// Execute a physical plan and get the stream.
// TODO: Deduplicate with service.proto
message PhysicalPlanExecute {
  /// The protobuf serialized physical plan.
  bytes physical_plan = 1;
}

message PollWorkResponse {
  SessionContextConfig config = 1;
  bytes work_id = 2; // UUID

  oneof response {
    DispatchAccess dispatch = 3;
    PhysicalPlanExecute plan = 4;
  }
}

message ExecutionBatchStream {
  bytes work_id = 1; // UUID
  // Input batches.
  bytes arrow_ipc = 2;

  // TODO: Error flag to indicate if the stream errored on the client side. We
  // don't need the error itself, we just need to know that we did error.
  //
  // Note that an error *inside* the message would indicated we had trouble
  // reading from the stream or encoding to IPC. The client will already have
  // access to the error.
  //
  // This would be used to just drop the stream to release resources.
}

message InstallBatchStreamResponse {}

service CoordinatorService {
  // Register a worker with the coordinator.
  rpc RegisterWorker(RegisterWorkerRequest) returns (RegisterWorkerResponse);

  // Deregister a worker with the coordinator.
  //
  // Should be called on node shutdown (mostly as an cleanup optimization,
  // correctness should not be affected if this isn't called).
  rpc DeregisterWorker(DeregisterWorkerRequest)
      returns (DeregisterWorkerResponse);

  // Periodic heartbeat from workers.
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);

  // Poll the coordinator for work.
  rpc PollWork(PollWorkRequest) returns (PollWorkResponse);

  // Installs a batch stream on the coordinator.
  rpc InstallBatchStream(stream ExecutionBatchStream)
      returns (InstallBatchStreamResponse);
}
