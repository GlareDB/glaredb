// Service definition for rpcsrv.
//
// # Request routing
//
// ```
//                1.                 2.
//    client    ----->  rpcproxy   <---->   cloud
// (cli/python)           |
//                        | 3.
//                        â–¼
//                 compute engine
//
// ```
//
// 1. Client makes request
//   - The client will place auth related metadata on the request
// 2. Proxy handles request
//   - The proxy pulls auth related metadata off the request and makes a request
//     to Cloud. Cloud returns back info on the database we're making a request
//     for, and where we should route the request.
// 3. Proxy sends authenticated request to compute engine.
//
// # Authentication
//
// When making a request from the client to the proxy, certain authentication
// parameters need to be provided on the request metadata:
//
// - "user"
// - "password"
// - "db_name"
// - "org"
// - "compute_engine" (optional)
//
// These parameters are then used by the proxy to make a request to Cloud for
// connection authentication. The response from Cloud indicates if the
// connection is authenticated. Cloud also returns additional data about how to
// connect to the remote compute engine.

syntax = "proto3";

package rpcsrv.service;

import "metastore/catalog.proto";

// Storage config for the session.
message SessionStorageConfig { optional string gcs_bucket = 1; }

// Request for initializing a remote session from the client.
message InitializeSessionRequestFromClient {
  // Where's the auth? Auth params are always set in the request metadata. This
  // goes for all requests, not just for initializing a session. See comment at
  // top.
}

// Request for initializing a session from the proxy.
//
// Fields in this request are generated based on what we receive back from
// Cloud.
message InitializeSessionRequestFromProxy {
  // Session storage config.
  SessionStorageConfig storage_conf = 2;

  // ID of database we're initializing a session for.
  bytes db_id = 3;
}

// Request for initializing a session.
message InitializeSessionRequest {
  oneof request {
    // Request if sent by the client.
    InitializeSessionRequestFromClient client = 1;
    // Request if sent by the proxy.
    InitializeSessionRequestFromProxy proxy = 2;
  }
}

message InitializeSessionResponse {
  // ID of session that was created. This ID needs to be provided on all future
  // requests.
  bytes session_id = 1;

  // The initial catalog for the database.
  metastore.catalog.CatalogState catalog = 2;
}

// Create a physical plan from the logical plan (used by `QueryPlanner`).
message CreatePhysicalPlanRequest {
  bytes session_id = 1;
  bytes logical_plan = 2;
}

// Dispatch the table access on remote server.
message DispatchAccessRequest {
  bytes session_id = 1;
  TableReference table_ref = 2;
}

// To scan the table provider.
message TableProviderScanRequest {
  // Provider information.
  bytes session_id = 1;
  bytes provider_id = 2;
  // Scan parameters.
  repeated uint64 projection = 3;
  repeated bytes filters = 4;
  optional uint64 limit = 5;
}

// To `insert_into` a table provider.
message TableProviderInsertIntoRequest {
  // Provider information.
  bytes session_id = 1;
  bytes provider_id = 2;
  // Physical plan ID to be used as input.
  bytes input_exec_id = 3;
}

// Execute a physical plan and get the stream.
message PhysicalPlanExecuteRequest {
  bytes session_id = 1;
  bytes exec_id = 2;
}

message TableProviderResponse {
  bytes id = 1;
  bytes schema = 2;
}

message PhysicalPlanResponse {
  bytes id = 1;
  bytes schema = 2;
}

message RecordBatchResponse {
  // Results of the execution.
  bytes arrow_ipc = 1;
}

message TableReference {
  optional string catalog = 1;
  optional string schema = 2;
  string table = 3;
}

message BroadcastExchangeRequest {
  // Session id.
  bytes session_id = 1;
  // Input id;
  bytes broadcast_input_id = 2;
  // Input batches.
  bytes arrow_ipc = 3;

  // TODO: Error flag to indicate if the stream errored on the client side. We
  // don't need the error itself, we just need to know that we did error.
  //
  // Note that an error *inside* the message would indicated we had trouble
  // reading from the stream or encoding to IPC. The client will already have
  // access to the error.
  //
  // This would be used to just drop the stream to release resources.
}

message BroadcastExchangeResponse {}

message CloseSessionRequest {
  // ID of session that we are closing.
  bytes session_id = 1;
}

message CloseSessionResponse {}

service ExecutionService {
  // Initializes a remote session.
  rpc InitializeSession(InitializeSessionRequest)
      returns (InitializeSessionResponse);

  // Create a physical plan on the remote server.
  rpc CreatePhysicalPlan(CreatePhysicalPlanRequest)
      returns (PhysicalPlanResponse);

  // Dispatch and create a table provider on the remote server.
  rpc DispatchAccess(DispatchAccessRequest) returns (TableProviderResponse);

  // Scan the table provider.
  rpc TableProviderScan(TableProviderScanRequest)
      returns (PhysicalPlanResponse);

  // Insert into the table provider.
  rpc TableProviderInsertInto(TableProviderInsertIntoRequest)
      returns (PhysicalPlanResponse);

  // Execute a physical plan.
  rpc PhysicalPlanExecute(PhysicalPlanExecuteRequest)
      returns (stream RecordBatchResponse);

  rpc BroadcastExchange(stream BroadcastExchangeRequest)
      returns (BroadcastExchangeResponse);

  // Close the remote session.
  rpc CloseSession(CloseSessionRequest) returns (CloseSessionResponse);
}
