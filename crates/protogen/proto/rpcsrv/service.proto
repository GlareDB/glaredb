// Service definition for rpcsrv.
//
// # Request routing
//
// ```
//                1.                 2.
//    client    ----->  rpcproxy   <---->   cloud
// (cli/python)           |
//                        | 3.
//                        â–¼
//                 compute engine
//
// ```
//
// 1. Client makes request
//   - The client will place auth related metadata on the request
// 2. Proxy handles request
//   - The proxy pulls auth related metadata off the request and makes a request
//     to Cloud. Cloud returns back info on the database we're making a request
//     for, and where we should route the request.
// 3. Proxy sends authenticated request to compute engine.
//
// # Authentication
//
// When making a request from the client to the proxy, certain authentication
// parameters need to be provided on the request metadata:
//
// - "user"
// - "password"
// - "db_name"
// - "org"
// - "compute_engine" (optional)
//
// These parameters are then used by the proxy to make a request to Cloud for
// connection authentication. The response from Cloud indicates if the
// connection is authenticated. Cloud also returns additional data about how to
// connect to the remote compute engine.
//
// The proxy will then set the following headers in the metadata map:
//
// - "proxied_for_database"
//
// Where the value is the UUID of the database (as a string, since that's what
// we get back from Cloud). The receiving node will then check to ensure that
// this database matches the database of the session being connected to.

syntax = "proto3";

package rpcsrv.service;

import "metastore/catalog.proto";

// Storage config for the session.
message SessionStorageConfig { optional string gcs_bucket = 1; }

// Request for initializing a remote session from the client.
message InitializeSessionRequestFromClient {
  // Where's the auth? Auth params are always set in the request metadata. This
  // goes for all requests, not just for initializing a session. See comment at
  // top.

  // Database ID that can be set by an integration test (bypassing proxy).
  optional bytes test_db_id = 1;
}

// Request for initializing a session from the proxy.
//
// Fields in this request are generated based on what we receive back from
// Cloud.
message InitializeSessionRequestFromProxy {
  // Session storage config.
  SessionStorageConfig storage_conf = 2;

  // ID of database we're initializing a session for.
  bytes db_id = 3;
}

// Request for initializing a session.
message InitializeSessionRequest {
  oneof request {
    // Request if sent by the client.
    InitializeSessionRequestFromClient client = 1;
    // Request if sent by the proxy.
    InitializeSessionRequestFromProxy proxy = 2;
  }
}

message InitializeSessionResponse {
  // ID of session that was created. This ID needs to be provided on all future
  // requests.
  bytes session_id = 1;

  // The initial catalog for the database.
  metastore.catalog.CatalogState catalog = 2;
}

message FetchCatalogRequest { bytes session_id = 1; }

message FetchCatalogResponse { metastore.catalog.CatalogState catalog = 1; }

// Dispatch the table access on remote server.
message DispatchAccessRequest {
  bytes session_id = 1;
  ResolvedTableReference table_ref = 2;
  repeated bytes args = 3;
  // gRPC doesn't really provide a way for Option<Vec<T>> or Option<Map<K,V>>
  // so we use a map and just check if it's empty or not in rust.
  map<string, bytes> options = 4;
}

// Execute a physical plan and get the stream.
message PhysicalPlanExecuteRequest {
  bytes session_id = 1;
  /// The protobuf serialized physical plan.
  bytes physical_plan = 2;
}

message TableProviderResponse {
  bytes id = 1;
  bytes schema = 2;
}

message RecordBatchResponse {
  // Results of the execution.
  bytes arrow_ipc = 1;
}

message InternalTableReference {
  // OID of the table in the catalog.
  uint32 table_oid = 1;
}

message ExternalTableReference {
  string database = 1;
  string schema = 2;
  string name = 3;
}

message ResolvedTableReference {
  oneof reference {
    // Table exists in our catalog.
    InternalTableReference internal = 1;
    // Table exists in an external system that we need to contact.
    ExternalTableReference external = 2;
  }
}

message BroadcastExchangeRequest {
  // Session id.
  bytes session_id = 1;
  // Input id;
  bytes broadcast_input_id = 2;
  // Input batches.
  bytes arrow_ipc = 3;

  // TODO: Error flag to indicate if the stream errored on the client side. We
  // don't need the error itself, we just need to know that we did error.
  //
  // Note that an error *inside* the message would indicated we had trouble
  // reading from the stream or encoding to IPC. The client will already have
  // access to the error.
  //
  // This would be used to just drop the stream to release resources.
}

message BroadcastExchangeResponse {}

message CloseSessionRequest {
  // ID of session that we are closing.
  bytes session_id = 1;
}

message CloseSessionResponse {}

service ExecutionService {
  // Initializes a remote session.
  rpc InitializeSession(InitializeSessionRequest)
      returns (InitializeSessionResponse);

  rpc FetchCatalog(FetchCatalogRequest) returns (FetchCatalogResponse);

  // Dispatch and create a table provider on the remote server.
  rpc DispatchAccess(DispatchAccessRequest) returns (TableProviderResponse);

  // Execute a physical plan.
  rpc PhysicalPlanExecute(PhysicalPlanExecuteRequest)
      returns (stream RecordBatchResponse);

  rpc BroadcastExchange(stream BroadcastExchangeRequest)
      returns (BroadcastExchangeResponse);

  // Close the remote session.
  rpc CloseSession(CloseSessionRequest) returns (CloseSessionResponse);
}
