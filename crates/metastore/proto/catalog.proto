// Catalog type definitions.
//
// These are generally the types used for persisting catalogs to storage, as
// well as RPC calls when fetching/mutating catalogs.
//
// Longer term our storage format may differ from our RPC format, but until
// then, keeping them in sync allows for faster iteration.

syntax = "proto3";

package metastore.catalog;

import "arrow.proto";

// The state of the catalog at some version.
message CatalogState {
  // Version of this catalog. Increments on every mutation.
  uint64 version = 1;

  // All entries in this catalog.
  //
  // ID -> Entry
  map<uint32, CatalogEntry> entries = 2;

  // next: 3
}

// Possible top-level catalog entries.
message CatalogEntry {
  oneof entry {
    DatabaseEntry database = 6; // TODO
    SchemaEntry schema = 1;
    TableEntry table = 2;
    ViewEntry view = 3;
    ConnectionEntry connection = 4;
    ExternalTableEntry external_table = 5;
  }
}

// Metadata for every entry in the catalog.
message EntryMeta {
  // Possible entry types in the catalog.
  //
  // Each entry of this type shares the same ID space.
  // TODO: Renumber
  enum EntryType {
    // Unknown catalog entry. We should error if this is encountered.
    UNKNOWN = 0;
    // Database schemas.
    SCHEMA = 1;
    // Database tables.
    TABLE = 2;
    // Database views.
    VIEW = 4;
    // Connections to external data sources.
    CONNECTION = 5;

    EXTERNAL_TABLE = 3;
    DATABASE = 6;
  }

  // Type of the entry.
  EntryType entry_type = 1;

  // ID of the entry. This id must be unique within the database, and will act
  // similarly to Postgres' OIDs.
  //
  // System entries have well-known IDs.
  uint32 id = 2;

  // ID of the parent entry.
  //
  // For tables and views, the parent id will be the schema id.
  //
  // For schemas, the parent will be the database id.
  uint32 parent = 3;

  // Name of this entry.
  string name = 4;

  // Whether or not this entry is builtin. Builtin entries cannot be dropped.
  bool builtin = 5;

  // next: 6
}

message DatabaseEntry {
  EntryMeta meta = 1;
  DatabaseOptions options = 2;
  // next: 3
}

message DatabaseOptions {
  // TODO
  oneof options {
    DatabaseOptionsInternal internal = 1;
    DatabaseOptionsPostgres postgres = 2;
    DatabaseOptionsBigQuery bigquery = 3;
  }
}

message DatabaseOptionsInternal {}

message DatabaseOptionsPostgres { string connection_string = 1; }

message DatabaseOptionsBigQuery {
  string service_account_key = 1;
  string project_id = 2;
}

message SchemaEntry {
  EntryMeta meta = 1;
  // next: 2
}

message TableEntry {
  EntryMeta meta = 1;

  // Columns in the table.
  repeated ColumnDefinition columns = 2;

  // next: 3
}

message ExternalTableEntry {
  EntryMeta meta = 1;

  // ID to the connection to use.
  uint32 connection_id = 2;

  // Table specific options to use when connecting to the external table.
  //
  // The external table type (postgres, bigquery, etc) is derived from these
  // options. The type derived here must match the connection type.
  TableOptions options = 3;

  // Columns in the external table.
  repeated ColumnDefinition columns = 4;

  // next: 5
}

message TableOptions {
  // Reserved just to keep table options/ connection options the same id for
  // each type. SSH connections (field id 8 in ConnectionOptions) are special
  // and don't provide any tables.
  reserved 8;

  // TODO: Renumber
  oneof options {
    TableOptionsInternal internal = 10;
    TableOptionsDebug debug = 1;
    TableOptionsPostgres postgres = 2;
    TableOptionsBigQuery bigquery = 3;
    TableOptionsLocal local = 4;
    TableOptionsGcs gcs = 5;
    TableOptionsS3 s3 = 6;
    TableOptionsMysql mysql = 7;
    TableOptionsMongo mongo = 9;
  }
}

message TableOptionsInternal {}

message TableOptionsDebug {
  // TODO: Probably make thise well-known id.
  string table_type = 1;
}

message TableOptionsPostgres {
  // Source schema to connect to on Postgres.
  string schema = 1;
  // Source table to connect to.
  string table = 2;
}

message TableOptionsBigQuery {
  // The dataset where table belongs.
  string dataset_id = 1;
  // Name of the table.
  string table_id = 2;
}

message TableOptionsLocal {
  // File path on the local machine.
  string location = 1;
}

message TableOptionsGcs {
  // Bucket the file belongs to.
  string bucket_name = 1;
  // Name of the object.
  string location = 2;
}

message TableOptionsS3 {
  // Region the bucket belongs to.
  string region = 1;
  // Bucket the file belongs to.
  string bucket_name = 2;
  // Name of the object.
  string location = 3;
}

message TableOptionsMysql {
  // Source schema to connect to on Mysql.
  string schema = 1;
  // Source table to connect to.
  string table = 2;
}

message TableOptionsMongo {
  // Database containing the collection.
  string database = 1;
  // The collection (table).
  string collection = 2;
}

message ColumnDefinition {
  // Name of the column in the table.
  string name = 1;

  // Field is nullable.
  bool nullable = 2;

  // Arrow type for the field.
  //
  // Note this will likely need to be expanded for complex types.
  arrow.ArrowType arrow_type = 3;

  // next: 4
}

message ViewEntry {
  EntryMeta meta = 1;

  // The sql statement for materializing the view.
  string sql = 2;

  // next: 3
}

message ConnectionEntry {
  EntryMeta meta = 1;

  // Options related to this connection.
  //
  // The connection type is derived from these options.
  ConnectionOptions options = 2;

  // next: 3
}

message ConnectionOptions {
  oneof options {
    ConnectionOptionsDebug debug = 1;
    ConnectionOptionsPostgres postgres = 2;
    ConnectionOptionsBigQuery bigquery = 3;
    ConnectionOptionsLocal local = 4;
    ConnectionOptionsGcs gcs = 5;
    ConnectionOptionsS3 s3 = 6;
    ConnectionOptionsSsh ssh = 7;
    ConnectionOptionsMysql mysql = 8;
    ConnectionOptionsMongo mongo = 9;
  }

  // next:9
}

message ConnectionOptionsDebug {}

message ConnectionOptionsPostgres {
  string connection_string = 1;
  reserved 2;
  optional uint32 ssh_tunnel = 3; // Connection id for ssh tunnel
}

message ConnectionOptionsBigQuery {
  string service_account_key = 1;
  string project_id = 2;
}

message ConnectionOptionsMysql {
  string connection_string = 1;
  reserved 2;
  optional uint32 ssh_tunnel = 3; // Connection id for ssh tunnel
}

message ConnectionOptionsLocal {}

message ConnectionOptionsGcs { string service_account_key = 1; }

message ConnectionOptionsS3 {
  string access_key_id = 1;
  string secret_access_key = 2;
}

message ConnectionOptionsSsh {
  string host = 1;
  string user = 2;
  uint32 port = 3; // Note the value here should not be larger than uint16 MAX
  bytes keypair = 4;
}

message ConnectionOptionsMongo { string connection_string = 1; }
