// Defintions for objects that get persisted to object storage.
//
// The structure of catalogs looks something like the following:
//
// lease      -> LeaseInformation
// catalog    -> PersistedCatalog
//
// - 'lease' facilitates locking the catalog.
// - 'catalog' is a blob containing the current database state, as well as some
//   additional metadata.
//
// 'catalog' may be split up into individual entries of groups of entries down
// the depending on how large catalogs get.

syntax = "proto3";

package metastore.storage;

import "google/protobuf/timestamp.proto";
import "catalog.proto";

message LeaseInformation {
  enum State {
    UNKOWN = 0;
    UNLOCKED = 1;
    LOCKED = 2;
  }
  // Current state of the lease.
  State state = 1;

  // Monotonically increasing generation of the lock.
  uint64 generation = 2;

  // Expiration of the lease. May be continually updated.
  //
  // If the state of the lock is 'LOCKED', and we're past this timestamp, then
  // the lock can be taken by another process. Processes should be updating this
  // in the background.
  //
  // This protects against a process acquiring the lock then crashing, causing
  // the lock to never be unlocked.
  google.protobuf.Timestamp expires_at = 3;

  // UUID of the process holding this lock. May be empty if the lock state is
  // 'UNLOCKED'.
  bytes held_by = 4;

  // next: 5
}

message PersistedCatalog {
  // The database that this catalog corresponds to.
  //
  // This should be a byte-serialized UUID (v4).
  bytes db_id = 1;

  // Persisted state of the catalog.
  catalog.CatalogState state = 2;

  // Persisted oid counter. Used for oid generation for new database objects.
  uint32 oid_counter = 3;

  // next: 4
}
