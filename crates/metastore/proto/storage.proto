// Defintions for objects that get persisted to object storage.
//
// The structure of catalogs looks something like the following:
//
// lease      -> LeaseInformation
// catalog    -> PersistedCatalog
//
// - 'lease' facilitates locking the catalog.
// - 'catalog' is a blob containing the current database state, as well as some
// additional metadata.
//
// 'catalog' may be split up into individual entries of groups of entries down
// the depending on how large catalogs get.

syntax = "proto3";

package metastore.storage;

import "google/protobuf/timestamp.proto";
import "catalog.proto";

message LeaseInformation {
  enum State {
    UNKOWN = 0;
    UNLOCKED = 1;
    LOCKED = 2;
  }
  // Current state of the lease.
  State state = 1;

  // Monotonically increasing generation of the lock.
  uint64 generation = 2;

  // Expiration of the lease. May be continually updated.
  //
  // If the state of the lock is 'LOCKED', and we're past this timestamp, then
  // the lock can be taken by another process. Processes should be updating this
  // in the background.
  //
  // This protects against a process acquiring the lock then crashing, causing
  // the lock to never be unlocked.
  google.protobuf.Timestamp expires_at = 3;

  // UUID of the process holding this lock. May be empty if the lock state is
  // 'UNLOCKED'.
  bytes held_by = 4;

  // next: 5
}

message CatalogMetadata {
  // Latest version of the persisted catalog. Used to build the object name for
  // the catalog blob.
  uint64 latest_version = 1;

  // Byte serialized UUID for the process that last wrote this metadata.
  bytes last_written_by = 2;
}

// The catalog as it exists in object storage.
//
// Note that this is very similar to `CatalogState`, however this is very likely
// a candidate of being broken up into separate objects (e.g. by entry type, or
// dependent entries). A single blob does the job for now, and its unlikely that
// this blob will get egregiously large.
message PersistedCatalog {
  // The version of this catalog.
  uint64 version = 1;

  // All entries in this catalog.
  //
  // ID -> Entry
  map<uint32, catalog.CatalogEntry> entries = 2;

  // Persisted oid counter. Used for oid generation for new database objects.
  uint32 oid_counter = 3;

  // next: 3
}
