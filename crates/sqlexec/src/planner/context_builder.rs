use crate::context::SessionContext;
use crate::functions::BuiltinScalarFunction;
use crate::functions::PgFunctionBuilder;
use crate::planner::dispatch::SessionDispatcher;
use crate::planner::errors::PlanError;
use datafusion::arrow::datatypes::DataType;
use datafusion::common::OwnedTableReference;
use datafusion::config::ConfigOptions;
use datafusion::datasource::DefaultTableSource;
use datafusion::datasource::TableProvider;
use datafusion::error::{DataFusionError, Result as DataFusionResult};
use datafusion::logical_expr::AggregateUDF;
use datafusion::logical_expr::ScalarUDF;
use datafusion::logical_expr::TableSource;
use datafusion::sql::planner::object_name_to_table_reference;
use datafusion::sql::planner::ContextProvider;
use datafusion::sql::sqlparser::ast::Visit;
use datafusion::sql::sqlparser::ast::{self, Visitor};
use datafusion::sql::TableReference;
use metastore::builtins::DEFAULT_CATALOG;
use std::collections::{HashMap, HashSet};
use std::ops::ControlFlow;
use std::sync::Arc;
use tracing::debug;

/// Helper for building a context provider for use with Datafusion's SQL
/// planner.
pub struct PlanContextBuilder<'a> {
    ctx: &'a SessionContext,
}

impl<'a> PlanContextBuilder<'a> {
    pub fn new(ctx: &'a SessionContext) -> Self {
        PlanContextBuilder { ctx }
    }

    /// Build a context suitable for planning a given sql statement.
    ///
    /// Under the hood, this will get all table providers from the session
    /// context that's taking part in the query.
    pub async fn build_plan_context(
        &self,
        statement: &ast::Statement,
    ) -> Result<PartialContextProvider<'a>, PlanError> {
        let mut visitor = RelationVistor::default();
        statement.visit(&mut visitor);
        let relations = visitor.relations;
        let ctes = visitor.ctes;

        // Only get actual tables. Top-level CTEs will be filtered out.
        // DataFusion's visitor is pretty barebones. If we wanted to get all
        // CTEs, we would have to match all expressions.
        //
        // This does mean there's an opportunity for a stack overflow due to our
        // late planning of views. A separate "depth" check should be
        // implemented.
        //
        // For example, the following query will not have `cte` in the map:
        //
        // SELECT 1 UNION ALL (WITH cte AS (SELECT 42) SELECT * FROM cte) ORDER BY 1
        let references = relations
            .into_iter()
            .filter_map(|rel| {
                if rel.0.len() == 1 && ctes.contains(&rel.0[0]) {
                    None
                } else {
                    Some(self.object_name_to_table_reference(rel))
                }
            })
            .collect::<Result<Vec<_>, _>>()?;

        self.build_plan_context_with_references(&references).await
    }

    /// Build a context using the provided table references.
    pub async fn build_plan_context_with_references(
        &self,
        references: impl IntoIterator<Item = &'_ TableReference<'static>>,
    ) -> Result<PartialContextProvider<'a>, PlanError> {
        let mut providers = HashMap::new();
        for reference in references {
            // Note that this should match the string generated by
            // `reference_to_string`.
            let s = reference.to_string(); // TODO: Don't create string?

            // Already have table provider.
            if providers.contains_key(&s) {
                continue;
            }

            let prov = match self.table_for_reference(reference).await {
                Ok(prov) => prov,
                Err(PlanError::FailedToFindTableForReference { .. }) => {
                    // Our visitor will pull out CTE aliases as table
                    // references. If we fail to find table provider, assume
                    // that it's a CTE.
                    //
                    // TODO: We can have better logic when walking the ast to
                    // skip or filter out CTE names to avoid trying to get
                    // a provider in the first place.
                    //
                    // Also note that while trying to resolve when we don't need
                    // to does have a performance implication, but it will be
                    // working with the in-memory catalog. However, once we have
                    // external databases, we'll want to make sure we _never_
                    // call out to the external system since that would slow
                    // things down significantly. The current logic means that
                    // this will be the case, but if we want fancier resolution,
                    // this is something we'll need to keep an eye on.
                    debug!(%reference, "skipping plan error, likely CTE");
                    continue;
                }
                Err(e) => return Err(e),
            };
            providers.insert(s, prov);
        }

        Ok(PartialContextProvider {
            providers,
            ctx: self.ctx,
        })
    }

    // Find a table provider the given reference, taking into account the
    // session's search path.
    pub async fn table_for_reference(
        &self,
        reference: &OwnedTableReference,
    ) -> Result<Arc<dyn TableProvider>, PlanError> {
        let dispatcher = SessionDispatcher::new(self.ctx);
        match &reference {
            TableReference::Bare { table } => {
                for schema in self.ctx.implicit_search_path_iter() {
                    // TODO
                    match dispatcher
                        .dispatch_access(DEFAULT_CATALOG, schema, table)
                        .await
                    {
                        Ok(table) => return Ok(table),
                        Err(e) if e.should_try_next_schema() => (), // Continue to next schema in search path.
                        Err(e) => {
                            return Err(PlanError::FailedToCreateTableProvider {
                                reference: reference.to_string(),
                                e,
                            });
                        }
                    }
                }
                Err(PlanError::FailedToFindTableForReference {
                    reference: reference.to_string(),
                })
            }
            TableReference::Partial { schema, table } => {
                // TODO
                let table = dispatcher
                    .dispatch_access(DEFAULT_CATALOG, schema, table)
                    .await?;
                Ok(table)
            }
            TableReference::Full {
                catalog,
                schema,
                table,
            } => {
                let table = dispatcher.dispatch_access(catalog, schema, table).await?;
                Ok(table)
            }
        }
    }

    /// Get a table reference from an ast object name. The table is not
    /// guaranteed to exist.
    pub fn object_name_to_table_reference(
        &self,
        name: ast::ObjectName,
    ) -> Result<OwnedTableReference, PlanError> {
        let normalize = self
            .ctx
            .get_df_state()
            .config_options()
            .sql_parser
            .enable_ident_normalization;

        let reference = object_name_to_table_reference(name, normalize)?;
        Ok(reference)
    }
}

/// Partial context provider with table providers required to fulfill a single
/// query.
///
/// NOTE: While `ContextProvider` is for _logical_ planning, DataFusion will
/// actually try to downcast the `TableSource` to a `TableProvider` during
/// physical planning. This only works with `DefaultTableSource` which is what
/// this adapter uses.
pub struct PartialContextProvider<'a> {
    providers: HashMap<String, Arc<dyn TableProvider>>,
    ctx: &'a SessionContext,
}

impl<'a> ContextProvider for PartialContextProvider<'a> {
    fn get_table_provider(&self, name: TableReference) -> DataFusionResult<Arc<dyn TableSource>> {
        let name = reference_to_string(name); // TODO: Don't create string?

        // It's a bug to have a missing provider here. It means we missed
        // resolving the table before we started SQL planning.
        let provider = self.providers.get(&name).ok_or_else(|| {
            DataFusionError::Plan(format!(
                "Context provider for SQL planner is missing a table: {}",
                name
            ))
        })?;

        Ok(Arc::new(DefaultTableSource::new(provider.clone())))
    }

    fn get_function_meta(&self, name: &str) -> Option<Arc<ScalarUDF>> {
        // TODO: We can build these async too.
        match BuiltinScalarFunction::try_from_name(name)
            .map(|f| Arc::new(f.build_scalar_udf(self.ctx)))
        {
            Some(func) => Some(func),
            None => PgFunctionBuilder::try_from_name(self.ctx, name, true),
        }
    }

    fn get_variable_type(&self, _variable_names: &[String]) -> Option<DataType> {
        None
    }

    fn get_aggregate_meta(&self, _name: &str) -> Option<Arc<AggregateUDF>> {
        None
    }

    fn options(&self) -> &ConfigOptions {
        self.ctx.get_df_state().config_options()
    }
}

fn reference_to_string(r: TableReference) -> String {
    match r {
        TableReference::Bare { table } => format!("{table}"),
        TableReference::Partial { schema, table } => format!("{schema}.{table}"),
        TableReference::Full {
            catalog,
            schema,
            table,
        } => format!("{catalog}.{schema}.{table}"),
    }
}

#[derive(Debug, Default)]
struct RelationVistor {
    relations: HashSet<ast::ObjectName>,
    ctes: HashSet<ast::Ident>,
}

impl Visitor for RelationVistor {
    type Break = ();

    fn pre_visit_relation(&mut self, relation: &ast::ObjectName) -> ControlFlow<()> {
        if !self.relations.contains(relation) {
            self.relations.insert(relation.clone());
        }
        ControlFlow::Continue(())
    }

    fn pre_visit_statement(&mut self, statement: &ast::Statement) -> ControlFlow<Self::Break> {
        if let ast::Statement::Query(query) = statement {
            if let Some(with) = &query.with {
                for table in &with.cte_tables {
                    self.ctes.insert(table.alias.name.clone());
                }
            }
        }
        ControlFlow::Continue(())
    }
}
